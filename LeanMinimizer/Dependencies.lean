/-
Copyright (c) 2024 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import LeanMinimizer.Basic
import Lean.Server.InfoUtils

/-!
# Dependency Analysis via InfoTrees

This module extracts dependencies between commands by analyzing the constants
referenced in their InfoTrees.

The approach is adapted from kim-em/lean-training-data.
-/

namespace LeanMinimizer

open Lean Elab Frontend Parser

/-! ## Compilation step tracking -/

/-- Results from processing a single command. -/
structure CompilationStep where
  /-- Index of this command (0-based) -/
  idx : Nat
  /-- The syntax of the command -/
  stx : Syntax
  /-- Environment before processing this command -/
  before : Environment
  /-- Environment after processing this command -/
  after : Environment
  /-- InfoTrees generated by this command -/
  trees : List InfoTree

/-- Process one command, returning a `CompilationStep` and whether we're done. -/
def processOneCommand (idx : Nat) : FrontendM (CompilationStep × Bool) := do
  let s := (← get).commandState
  let before := s.env
  let done ← processCommand
  let s' := (← get).commandState
  let after := s'.env
  -- Note: elabCommandTopLevel clears trees at start of each command, so we capture all of them
  let trees := s'.infoState.trees.toList
  let stx := (← get).commands.back!
  return ({ idx, stx, before, after, trees }, done)

/-- Process all commands, collecting CompilationSteps. -/
partial def processAllCommands (idx : Nat := 0) : FrontendM (Array CompilationStep) := do
  let (step, done) ← processOneCommand idx
  if done then
    return #[step]
  else
    return #[step] ++ (← processAllCommands (idx + 1))

/-- Run the frontend on input, returning all CompilationSteps. -/
unsafe def runFrontend (input : String) (fileName : String) : IO (Array CompilationStep) := do
  let inputCtx := Parser.mkInputContext input fileName
  let (header, parserState, messages) ← Parser.parseHeader inputCtx

  if messages.hasErrors then
    throw <| IO.userError "File has header errors"

  let (env, messages) ← processHeader header {} messages inputCtx

  if messages.hasErrors then
    throw <| IO.userError "Header processing failed"

  let commandState := Command.mkState env messages {}
  let commandState := { commandState with infoState.enabled := true }

  let frontendState : Frontend.State := {
    commandState := commandState
    parserState := parserState
    cmdPos := parserState.pos
  }

  let context : Frontend.Context := { inputCtx := inputCtx }

  let (steps, _) ← (processAllCommands 0).run context |>.run frontendState
  return steps

/-! ## InfoTree analysis -/

/-- Extract all constant names referenced in an InfoTree -/
partial def extractConstantsFromInfoTree (tree : InfoTree) : NameSet :=
  match tree with
  | .context _ t => extractConstantsFromInfoTree t
  | .node info children =>
    let fromChildren := children.foldl (init := {}) fun acc child =>
      acc.union (extractConstantsFromInfoTree child)
    match info with
    | .ofTermInfo ti =>
      match ti.expr with
      | .const name _ => fromChildren.insert name
      | _ => ti.expr.foldConsts fromChildren fun name acc => acc.insert name
    | .ofFieldInfo fi => fromChildren.insert fi.projName
    | _ => fromChildren
  | .hole _ => {}

/-- Get all constants added to the environment by a compilation step -/
def getNewConstants (step : CompilationStep) : NameSet :=
  step.after.constants.fold (init := {}) fun acc name _ =>
    if step.before.constants.contains name then acc
    else acc.insert name

/-- Get all constants referenced in the InfoTrees of a compilation step -/
def getReferencedConstants (step : CompilationStep) : NameSet :=
  step.trees.foldl (init := {}) fun acc tree =>
    acc.union (extractConstantsFromInfoTree tree)

/-! ## Dependency graph -/

/-- Result of analyzing a single command -/
structure CommandAnalysis where
  /-- Index of this command -/
  idx : Nat
  /-- Constants referenced by this command (from InfoTrees) -/
  referencedConstants : NameSet
  /-- Constants defined by this command (added to environment) -/
  definedConstants : NameSet
  deriving Inhabited

/-- Analyze compilation steps to extract dependency information -/
def analyzeSteps (steps : Array CompilationStep) : Array CommandAnalysis :=
  steps.map fun step => {
    idx := step.idx
    referencedConstants := getReferencedConstants step
    definedConstants := getNewConstants step
  }

/-- Build a dependency map: for each command index, which other command indices does it depend on? -/
def buildDependencyMap (analyses : Array CommandAnalysis) : Array (Array Nat) := Id.run do
  -- First, build a map from constant name to defining command index
  let mut constantToCmd : Std.HashMap Name Nat := {}
  for analysis in analyses do
    for name in analysis.definedConstants do
      constantToCmd := constantToCmd.insert name analysis.idx

  -- Now, for each command, find which commands define the constants it references
  let mut result : Array (Array Nat) := #[]
  for analysis in analyses do
    let mut deps : Array Nat := #[]
    for name in analysis.referencedConstants do
      if let some defIdx := constantToCmd[name]? then
        if defIdx != analysis.idx && !deps.contains defIdx then
          deps := deps.push defIdx
    result := result.push deps

  return result

/-- Compute the transitive closure of dependencies from a set of starting indices.
    Returns all indices reachable from the starting set. -/
def computeReachable (deps : Array (Array Nat)) (startIndices : Array Nat) : Array Nat := Id.run do
  let n := deps.size
  let mut visited : Array Bool := Array.replicate n false
  let mut queue := startIndices.toList

  -- Mark starting indices as visited
  for i in startIndices do
    if i < n then
      visited := visited.set! i true

  -- BFS to find all reachable nodes
  while !queue.isEmpty do
    match queue with
    | [] => break
    | idx :: rest =>
      queue := rest
      if h : idx < deps.size then
        for dep in deps[idx] do
          if dep < n then
            if !visited[dep]! then
              visited := visited.set! dep true
              queue := queue ++ [dep]

  -- Collect all visited indices
  let mut result : Array Nat := #[]
  for i in [:n] do
    if visited[i]! then
      result := result.push i

  return result

/-! ## Split heuristic -/

/-- Find which command indices define constants that are referenced by the invariant section. -/
def findInvariantDependencies (stepsBeforeMarker : Array CompilationStep)
    (invariantSteps : Array CompilationStep) : Array Nat := Id.run do
  -- Build map from constant name to defining command index
  let mut constantToCmd : Std.HashMap Name Nat := {}
  for step in stepsBeforeMarker do
    let newConsts := getNewConstants step
    for name in newConsts do
      constantToCmd := constantToCmd.insert name step.idx

  -- Find all constants referenced by the invariant section
  let mut invariantRefs : NameSet := {}
  for step in invariantSteps do
    invariantRefs := invariantRefs.union (getReferencedConstants step)

  -- Find which commands before marker define constants used by invariant
  let mut result : Array Nat := #[]
  for name in invariantRefs do
    if let some idx := constantToCmd[name]? then
      if !result.contains idx then
        result := result.push idx

  return result

end LeanMinimizer
