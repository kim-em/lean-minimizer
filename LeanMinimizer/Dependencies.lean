/-
Copyright (c) 2024 Lean FRO, LLC. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Kim Morrison
-/
import LeanMinimizer.Basic
import Lean.Server.InfoUtils

/-!
# Dependency Analysis via InfoTrees

This module extracts dependencies between commands by analyzing the constants
referenced in their InfoTrees.

The approach is adapted from kim-em/lean-training-data.
-/

namespace LeanMinimizer

open Lean Elab Frontend Parser

/-! ## Compilation step tracking -/

/-- Results from processing a single command. -/
structure CompilationStep where
  /-- Index of this command (0-based) -/
  idx : Nat
  /-- The syntax of the command -/
  stx : Syntax
  /-- Start position in the source file (includes leading whitespace/comments) -/
  startPos : String.Pos.Raw
  /-- End position in the source file (including trailing whitespace) -/
  endPos : String.Pos.Raw
  /-- Environment before processing this command -/
  before : Environment
  /-- Environment after processing this command -/
  after : Environment
  /-- InfoTrees generated by this command -/
  trees : List InfoTree

/-- Convert a CompilationStep to CmdInfo (drops elaboration data, keeps positions) -/
def CompilationStep.toCmdInfo (step : CompilationStep) : CmdInfo :=
  { idx := step.idx, stx := step.stx, startPos := step.startPos, endPos := step.endPos }

/-- Result from running the frontend on a file -/
structure FrontendResult where
  /-- The parsed header syntax -/
  header : Syntax
  /-- End position of header (including trailing whitespace) -/
  headerEndPos : String.Pos.Raw
  /-- All compilation steps -/
  steps : Array CompilationStep

/-- Process one command, returning a `CompilationStep` and whether we're done.
    Takes the start position (end of previous command) and returns the end position. -/
def processOneCommand (idx : Nat) (startPos : String.Pos.Raw) :
    FrontendM (CompilationStep × Bool × String.Pos.Raw) := do
  let s := (← get).commandState
  let before := s.env
  let done ← processCommand
  let s' := (← get).commandState
  let after := s'.env
  -- Note: elabCommandTopLevel clears trees at start of each command, so we capture all of them
  let trees := s'.infoState.trees.toList
  let stx := (← get).commands.back!
  let endPos := (← get).parserState.pos
  return ({ idx, stx, startPos, endPos, before, after, trees }, done, endPos)

/-- Process all commands, collecting CompilationSteps with positions. -/
partial def processAllCommands (idx : Nat := 0) (startPos : String.Pos.Raw) :
    FrontendM (Array CompilationStep) := do
  let (step, done, endPos) ← processOneCommand idx startPos
  if done then
    return #[step]
  else
    return #[step] ++ (← processAllCommands (idx + 1) endPos)

/-- Run the frontend on input, returning FrontendResult with header and all CompilationSteps. -/
unsafe def runFrontend (input : String) (fileName : String) : IO FrontendResult := do
  enableInitializersExecution
  let inputCtx := Parser.mkInputContext input fileName
  let (header, parserState, messages) ← Parser.parseHeader inputCtx

  if messages.hasErrors then
    let errMsgs ← messages.toList.filterMapM fun msg => do
      if msg.severity == .error then pure (some (← msg.toString)) else pure none
    throw <| IO.userError s!"File has header errors:\n{"\n".intercalate errMsgs}"

  let (env, messages) ← processHeader header {} messages inputCtx

  if messages.hasErrors then
    let errMsgs ← messages.toList.filterMapM fun msg => do
      if msg.severity == .error then pure (some (← msg.toString)) else pure none
    throw <| IO.userError s!"Header processing failed:\n{"\n".intercalate errMsgs}"

  let headerEndPos := parserState.pos

  let commandState := Command.mkState env messages {}
  let commandState := { commandState with infoState.enabled := true }

  let frontendState : Frontend.State := {
    commandState := commandState
    parserState := parserState
    cmdPos := parserState.pos
  }

  let context : Frontend.Context := { inputCtx := inputCtx }

  let (steps, _) ← (processAllCommands 0 headerEndPos).run context |>.run frontendState
  return { header, headerEndPos, steps }

/-! ## InfoTree analysis -/

/-- Extract all constant names referenced in an InfoTree -/
partial def extractConstantsFromInfoTree (tree : InfoTree) : NameSet :=
  match tree with
  | .context _ t => extractConstantsFromInfoTree t
  | .node info children =>
    let fromChildren := children.foldl (init := {}) fun acc child =>
      acc.union (extractConstantsFromInfoTree child)
    match info with
    | .ofTermInfo ti =>
      match ti.expr with
      | .const name _ => fromChildren.insert name
      | _ => ti.expr.foldConsts fromChildren fun name acc => acc.insert name
    | .ofFieldInfo fi => fromChildren.insert fi.projName
    | _ => fromChildren
  | .hole _ => {}

/-- Get all constants added to the environment by a compilation step -/
def getNewConstants (step : CompilationStep) : NameSet :=
  step.after.constants.fold (init := {}) fun acc name _ =>
    if step.before.constants.contains name then acc
    else acc.insert name

/-- Get all constants referenced in the InfoTrees of a compilation step -/
def getReferencedConstants (step : CompilationStep) : NameSet :=
  step.trees.foldl (init := {}) fun acc tree =>
    acc.union (extractConstantsFromInfoTree tree)

/-! ## Dependency graph -/

/-- Result of analyzing a single command -/
structure CommandAnalysis where
  /-- Index of this command -/
  idx : Nat
  /-- Constants referenced by this command (from InfoTrees) -/
  referencedConstants : NameSet
  /-- Constants defined by this command (added to environment) -/
  definedConstants : NameSet
  deriving Inhabited

/-- Analyze compilation steps to extract dependency information -/
def analyzeSteps (steps : Array CompilationStep) : Array CommandAnalysis :=
  steps.map fun step => {
    idx := step.idx
    referencedConstants := getReferencedConstants step
    definedConstants := getNewConstants step
  }

/-- Build a dependency map: for each command index, which other command indices does it depend on? -/
def buildDependencyMap (analyses : Array CommandAnalysis) : Array (Array Nat) := Id.run do
  -- First, build a map from constant name to defining command index
  let mut constantToCmd : Std.HashMap Name Nat := {}
  for analysis in analyses do
    for name in analysis.definedConstants do
      constantToCmd := constantToCmd.insert name analysis.idx

  -- Now, for each command, find which commands define the constants it references
  let mut result : Array (Array Nat) := #[]
  for analysis in analyses do
    let mut deps : Array Nat := #[]
    for name in analysis.referencedConstants do
      if let some defIdx := constantToCmd[name]? then
        if defIdx != analysis.idx && !deps.contains defIdx then
          deps := deps.push defIdx
    result := result.push deps

  return result

/-- Compute the transitive closure of dependencies from a set of starting indices.
    Returns all indices reachable from the starting set. -/
def computeReachable (deps : Array (Array Nat)) (startIndices : Array Nat) : Array Nat := Id.run do
  let n := deps.size
  let mut visited : Array Bool := Array.replicate n false
  let mut queue := startIndices.toList

  -- Mark starting indices as visited
  for i in startIndices do
    if i < n then
      visited := visited.set! i true

  -- BFS to find all reachable nodes
  while !queue.isEmpty do
    match queue with
    | [] => break
    | idx :: rest =>
      queue := rest
      if h : idx < deps.size then
        for dep in deps[idx] do
          if dep < n then
            if !visited[dep]! then
              visited := visited.set! dep true
              queue := queue ++ [dep]

  -- Collect all visited indices
  let mut result : Array Nat := #[]
  for i in [:n] do
    if visited[i]! then
      result := result.push i

  return result

/-! ## Split heuristic -/

/-- Find which command indices define constants that are referenced by the invariant section. -/
def findInvariantDependencies (stepsBeforeMarker : Array CompilationStep)
    (invariantSteps : Array CompilationStep) : Array Nat := Id.run do
  -- Build map from constant name to defining command index
  let mut constantToCmd : Std.HashMap Name Nat := {}
  for step in stepsBeforeMarker do
    let newConsts := getNewConstants step
    for name in newConsts do
      constantToCmd := constantToCmd.insert name step.idx

  -- Find all constants referenced by the invariant section
  let mut invariantRefs : NameSet := {}
  for step in invariantSteps do
    invariantRefs := invariantRefs.union (getReferencedConstants step)

  -- Find which commands before marker define constants used by invariant
  -- Use HashSet for O(1) duplicate checking instead of O(n) Array.contains
  let mut resultSet : Std.HashSet Nat := {}
  for name in invariantRefs do
    if let some idx := constantToCmd[name]? then
      resultSet := resultSet.insert idx

  return resultSet.toArray

/-! ## Declaration body detection -/

/-- Check if syntax is a declaration kind that has a body we can replace -/
def isDeclarationKind (stx : Syntax) : Bool :=
  stx.isOfKind `Lean.Parser.Command.declaration

/-- Find the inner declaration (theorem, def, etc.) from a declaration command.
    Declaration syntax is: declModifiers (abbrev | definition | theorem | ...) -/
def getInnerDecl? (stx : Syntax) : Option Syntax := do
  if !isDeclarationKind stx then
    failure
  if stx.getNumArgs < 2 then
    failure
  return stx.getArg 1

/-- Find declVal syntax within an inner declaration (theorem/def/etc).
    declVal is one of: declValSimple | declValEqns | whereStructInst -/
def findDeclVal? (inner : Syntax) : Option Syntax := do
  for i in [:inner.getNumArgs] do
    let child := inner.getArg i
    if child.isOfKind `Lean.Parser.Command.declValSimple ||
       child.isOfKind `Lean.Parser.Command.declValEqns ||
       child.isOfKind `Lean.Parser.Command.whereStructInst then
      return child
  failure

/-- Get the body syntax from declValSimple (`:= body`).
    declValSimple has structure: ":=" body termination? whereDecls? -/
def getDeclValSimpleBody? (declVal : Syntax) : Option Syntax := do
  if !declVal.isOfKind `Lean.Parser.Command.declValSimple then
    failure
  if declVal.getNumArgs < 2 then
    failure
  return declVal.getArg 1

/-- Get the body range from declValSimple -/
def getDeclValSimpleBodyRange? (declVal : Syntax) : Option (String.Pos.Raw × String.Pos.Raw) := do
  let body ← getDeclValSimpleBody? declVal
  let startPos ← body.getPos?
  let endPos ← body.getTailPos?
  return (startPos, endPos)

/-- Get body range from whereStructInst.
    whereStructInst has structure: "where" structInstFields -/
def getWhereStructInstBodyRange? (declVal : Syntax) : Option (String.Pos.Raw × String.Pos.Raw) := do
  if !declVal.isOfKind `Lean.Parser.Command.whereStructInst then
    failure
  -- The whole whereStructInst is the "body" we might want to replace
  let startPos ← declVal.getPos?
  let endPos ← declVal.getTailPos?
  return (startPos, endPos)

/-- Get the body range for a declaration.
    Returns the range of the part we want to replace with sorry. -/
def getDeclBodyRange? (stx : Syntax) : Option (String.Pos.Raw × String.Pos.Raw) := do
  let inner ← getInnerDecl? stx
  let declVal ← findDeclVal? inner
  getDeclValSimpleBodyRange? declVal <|> getWhereStructInstBodyRange? declVal

end LeanMinimizer
